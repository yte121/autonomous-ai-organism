import { api } from "encore.dev/api";
import { organismDB } from "./db";
import { llmClient } from "../llm/client";
import type { Organism, LearningRequest, KnowledgeEntry } from "./types";

// Enables organism to learn from codebases, internet, and technologies.
export const learn = api<LearningRequest, { knowledge_entries: KnowledgeEntry[] }>(
  { expose: true, method: "POST", path: "/organisms/:organism_id/learn" },
  async (req) => {
    const organism = await organismDB.queryRow<Organism>`
      SELECT * FROM organisms WHERE id = ${req.organism_id} AND status = 'active'
    `;

    if (!organism) {
      throw new Error("Organism not found or not active");
    }

    const knowledgeEntries: KnowledgeEntry[] = [];

    switch (req.source_type) {
      case 'codebase':
        const codebaseKnowledge = await analyzeCodebase(req.source_url || '', req.learning_objectives);
        knowledgeEntries.push(...codebaseKnowledge);
        break;
      
      case 'internet':
        const internetKnowledge = await researchInternet(req.learning_objectives);
        knowledgeEntries.push(...internetKnowledge);
        break;
      
      case 'technology_docs':
        const techKnowledge = await analyzeTechnologyDocs(req.source_url || '', req.learning_objectives);
        knowledgeEntries.push(...techKnowledge);
        break;
    }

    // Store knowledge entries
    for (const entry of knowledgeEntries) {
      await organismDB.exec`
        INSERT INTO knowledge_base (organism_id, knowledge_type, content, source, confidence_score)
        VALUES (
          ${req.organism_id},
          ${entry.knowledge_type},
          ${JSON.stringify(entry.content)},
          ${entry.source},
          ${entry.confidence_score}
        )
      `;
    }

    // Update organism's learned technologies and capabilities
    await updateOrganismLearning(req.organism_id, knowledgeEntries);

    return { knowledge_entries: knowledgeEntries };
  }
);

async function analyzeCodebase(sourceUrl: string, objectives: string[]): Promise<KnowledgeEntry[]> {
  const entries: KnowledgeEntry[] = [];
  
  // Simulate codebase analysis
  const patterns = [
    'design_patterns',
    'optimization_techniques',
    'error_handling_strategies',
    'architectural_patterns'
  ];

  for (const pattern of patterns) {
    if (objectives.some(obj => obj.toLowerCase().includes(pattern.replace('_', ' ')))) {
      entries.push({
        id: '', // Will be generated by DB
        organism_id: '',
        knowledge_type: 'codebase_analysis',
        content: {
          pattern_type: pattern,
          implementation_details: `Analyzed ${pattern} from ${sourceUrl}`,
          best_practices: [`Best practice for ${pattern}`],
          code_examples: [`Example code for ${pattern}`]
        },
        source: sourceUrl,
        confidence_score: 0.8,
        created_at: new Date(),
        updated_at: new Date()
      });
    }
  }

  return entries;
}

async function researchInternet(objectives: string[]): Promise<KnowledgeEntry[]> {
  const entries: KnowledgeEntry[] = [];
  
  for (const objective of objectives) {
    // Use the llmClient to perform research.
    // We can use 'intermediate' as a good default depth for autonomous research.
    const researchData = await llmClient.generateInternetResearch(objective, 'intermediate');

    // The llmClient returns a structured object. We need to format it
    // into the KnowledgeEntry format that the 'learn' function expects.
    const content = {
      topic: objective,
      research_summary: researchData.overview,
      key_insights: researchData.trends,
      related_technologies: researchData.related_technologies,
      implementation_strategies: researchData.best_practices,
      applications: researchData.applications,
      limitations: researchData.limitations,
      future_outlook: researchData.future_outlook
    };

    entries.push({
      id: '', // Will be generated by DB
      organism_id: '', // Will be assigned by the caller
      knowledge_type: 'internet_research',
      content: content,
      source: researchData.sources.join(', ') || 'internet_research',
      confidence_score: researchData.confidence || 0.75,
      created_at: new Date(researchData.timestamp || Date.now()),
      updated_at: new Date(researchData.timestamp || Date.now())
    });
  }

  return entries;
}

async function analyzeTechnologyDocs(sourceUrl: string, objectives: string[]): Promise<KnowledgeEntry[]> {
  const entries: KnowledgeEntry[] = [];
  
  // Simulate technology documentation analysis
  for (const objective of objectives) {
    entries.push({
      id: '',
      organism_id: '',
      knowledge_type: 'technology_pattern',
      content: {
        technology: objective,
        documentation_summary: `Documentation analysis for ${objective}`,
        api_patterns: [`API pattern for ${objective}`],
        usage_examples: [`Usage example for ${objective}`],
        optimization_tips: [`Optimization tip for ${objective}`]
      },
      source: sourceUrl,
      confidence_score: 0.9,
      created_at: new Date(),
      updated_at: new Date()
    });
  }

  return entries;
}

async function updateOrganismLearning(organismId: string, knowledgeEntries: KnowledgeEntry[]): Promise<void> {
  const organism = await organismDB.queryRow<Organism>`
    SELECT * FROM organisms WHERE id = ${organismId}
  `;

  if (!organism) return;

  const newTechnologies = new Set(organism.learned_technologies);
  const newCapabilities = new Set(organism.capabilities);
  const updatedAnalysis = { ...organism.code_analysis };

  // Extract new technologies and capabilities from knowledge
  knowledgeEntries.forEach(entry => {
    if (entry.knowledge_type === 'technology_pattern') {
      newTechnologies.add(entry.content.technology);
      newCapabilities.add(`${entry.content.technology}_integration`);
    }
    
    if (entry.knowledge_type === 'codebase_analysis') {
      updatedAnalysis.extracted_patterns = updatedAnalysis.extracted_patterns || [];
      updatedAnalysis.extracted_patterns.push(entry.content.pattern_type);
      newCapabilities.add(`${entry.content.pattern_type}_implementation`);
    }
  });

  // Update learning efficiency
  const updatedMetrics = { ...organism.performance_metrics };
  updatedMetrics.learning_efficiency = Math.min(1.0, updatedMetrics.learning_efficiency + 0.1);

  await organismDB.exec`
    UPDATE organisms SET 
      learned_technologies = ${JSON.stringify(Array.from(newTechnologies))},
      capabilities = ${JSON.stringify(Array.from(newCapabilities))},
      code_analysis = ${JSON.stringify(updatedAnalysis)},
      performance_metrics = ${JSON.stringify(updatedMetrics)},
      updated_at = NOW()
    WHERE id = ${organismId}
  `;
}
